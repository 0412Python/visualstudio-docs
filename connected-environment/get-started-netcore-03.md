# Getting Started on Connected Environment with .NET Core

Previous step: [Create a Kubernetes Development Environment in Azure](get-started-netcore-02.md)

## Create an ASP.NET Core Web App
We'll use the `dotnet` CLI to create an ASP.NET Core Web App in a folder named `webfrontend`.
```
dotnet new mvc --name webfrontend
```

## Initialize Code for Docker and Kubernetes Development
So far, we have a basic ASP.NET Core MVP web app - we'll now containerize it by creating assets that define the app's container and how it will deploy to Kubernetes. This is easy to do with Connected Environment: 

1. Launch VS Code and open the `webfrontend` folder. 
1. Open the Integrated Terminal in VS Code (using the **View | Integrated Terminal** menu).
1. Run this command (be sure that **webfrontend** is your current folder):

```
vsce init --public
```

The Connected Environment CLI's ```init``` command generates Docker and Kubernetes assets with default settings:
* `./Dockerfile` describes the app's container image, and how the source code is built and runs within the container.
* A **Helm chart** under `./charts/webfrontend` describes how to deploy the container to Kubernetes.

For now it isn't necessary to understand the full content of these files. It's worth pointing out, however, that **the same Kubernetes and Docker configuration-as-code assets can be used from development through to production, thus giving us high consistency across those environments.**
 
A file named `./vsce.yaml` is also generated by the `init` command, and it is the configuration file for Connected Environment. It complements the Docker and Kubernetes artifacts with additional configuration that enables an iterative development experience in Azure. For example, the default Helm chart does not expose any public endpoints. Sometimes, however, it is useful to temporarily open up a public endpoint during development so you can test your code, say, from a mobile device or a webhook URL. The `--public` parameter we passed to `init` adds configuration in the `vsce.yaml` file to open up a development-only SSL public endpoint.

## Ensure the Development Environment Was Successfully Created
In the [previous section](get-started-netcore-02.md), we kicked off the `vsce env create` command to create a development environment in Azure. It takes several minutes to complete, so check back that it was successfully created. You can always check the environments you have access to, and their status, with this command: `vsce env list`. 

## Build and Run Code in Kubernetes
Let's run our code! In the terminal window, run this command from the **root code folder**, i.e. webfrontend:

```
vsce up
```

Keep an eye on the command's output, you'll notice several things as it progresses:
1. Source code is synced to the development environment in Azure.
1. A container image is built in Azure, as specified by the Docker assets in your code folder.
1. A container instance is deployed to Kubernetes, specified by your Kubernetes assets.
1. Information about the container's endpoint(s) is displayed. In our case, we're expecting a public HTTPS URL.
1. Assuming the above stages complete successfully, you should begin to see `stdout` (and `stderr`) output as the container starts up.

> [!Note]
> These steps will take longer the first time the `up` command is run - they are considerably shortened on subsequent runs.

## Test the App
Scan the console output for information about the public URL that was created by the `up` command. It will be in the form: `https://<servicename>-<environmentname>.vsce.io`. For example: https://webfrontend-myenvironment.vsce.io.

Open this URL in a browser window - or better yet, from a mobile device - and you should see the web app load! As the container executes, `stdout` and `stderr` output is streamed to the terminal window.

## Update a Content File
Connected Environment isn't just about getting code running in Kubernetes - it's about enabling you to quickly and iteratively seeing your code changes take affect in a Kubernetes environment in the cloud.

1. Locate the file `./Views/Home/Index.cshtml` and make an edit to the HTML. For example, change line 70 that reads `<h2>Application uses</h2>` to something like: `<h2>Hello Azure!</h2>`
1. Save the file. Moments later, in the Terminal window you'll see a message saying the code was successfully synced in the Terminal window.
1. Go to your browser and refresh the page. You should see the web page display the updated HTML.

What happened? Edits to content files, like HTML and CSS, don't require re-compilation in a .NET Core web app, so an active `vsce up` command will automatically sync any modified content files into the running container in Azure, thereby providing a fast way to see your changes as you code.

## Update a Code File
Updating code files requires a little more work, because a .NET Core app needs to build again and produce updated application binaries. The simplest method from the command-line is to hit `Ctrl+C` in the terminal window (to stop `vsce up`), edit code, and then re-run `vsce up`. This rebuilds the container image and redeploys it. You will now be able to see your code changes take effect in the running application.


But there is an even faster method if we use the VS Code extension for Connected Environment, which we'll now explore in the next section. 
> [!div class="nextstepaction"]
> [Debugging a container in Kubernetes](get-started-netcore-04.md)

