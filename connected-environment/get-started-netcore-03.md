# Getting Started on Connected Environment with .NET Core

Previous step: [Install Tools](get-started-netcore-02.md)

## Create an ASP.NET Core Web App
Run this command to create an ASP.NET Core Web App in a folder named `webfrontend`.
```
dotnet new mvc --name webfrontend
```

## Initialize Code for Docker and Kubernetes Development
So far, we have a basic .NET Core MVP web app - we'll now containerize the app by creating assets that define its container and how it will deploy to Kubernetes. This is easy to do with Connected Environment: 

1. Launch VS Code and open the `webfrontend` folder. 
1. Open the Integrated Terminal in VS Code (using the **View | Integrated Terminal** menu).
1. Run the initialization command using Connected Environment's command-line interface:
```
vsce init --public
```

The ```init``` command generates Docker and Kubernetes assets with default settings:
* `./Dockerfile` describes the app's container image, and how the source code is built and runs within the container.
* A **Helm chart** under `./charts/webfrontend` describes how to deploy the container to Kubernetes.

For now it isn't necessary to understand the full content of these files. It's worth pointing out, however, that **the same Kubernetes and Docker configuration-as-code assets can be used from development to production, thus giving us higher consistency across those environments.**
 
A file named `./vsce.yaml` is also generated by the `init` command, and it is the configuration file for Connected Environment. It complements the Docker and Kubernetes artifacts with additional configuration that enables an iterative development experience in Azure. For example, the default Helm chart does not expose any public endpoints. Sometimes, however, it is useful to temporarily open up a public endpoint during development so you can test your code, say, from a mobile device or a webhook URL. The `--public` parameter we passed to `init` adds configuration in the `vsce.yaml` file to open up a development-only SSL public endpoint.

## Build and Run Code in Kubernetes
Let's run our code! In the terminal window, type:
```vsce up```

Keep an eye on the command's output, and you'll notice a number of things:
1. Source code is synced to the development environment in Azure.
1. A container image is built in Azure, as specified by the Docker assets in your code folder.
1. A container instance is deployed to Kubernetes, as specified by your Kubernetes assets.
1. Information about the container's endpoint(s) is displayed.
1. If the above steps pass, you should also start seeing any `stdout` (and `stderr`) output as the container starts up.

## Test the App
Scan the console output for information about the public URL that was created by the `up` command. It will be in the form: `https://<servicename>-<environmentname>.vsce.io`. For example: https://webfrontend-myenvironment.vsce.io.

Open this URL in a browser window - or better yet, from a mobile device - and you should see the web app load! As the container executes, console output is streamed to the terminal window.

## Update a Content File
Connected Environment isn't just about getting code running in Kubernetes - it's about providing an iterative experience for quickly seeing your code changes take affect in a Kubernetes environment in the cloud.

1. Locate the file `./Views/Home/Index.cshtml` and make an edit to the HTML. For example, change line 70 that reads `<h2>Application uses</h2>` to something like: `<h2>Hello Azure!</h2>`
1. Save the file. Moments later, in the Terminal window you'll see a message saying the code was successfully synced in the Terminal window.
1. Go to your browser and refresh the page. You should see the web page display the updated HTML.

**What happened?** Edits to content files, like HTML and CSS, don't require re-compilation, so an active `vsce up` command simply syncs the updated content files into the running container, thereby providing a faster way to see your changes as you code.

## Update a Code File
Updating code files requires a little more work, because a .NET Core app needs to be recompiled to produce updated application binaries. The simplest method from the command-line is to hit `Ctrl+C` in the terminal window (which stops `vsce up`), make some code edits and hit save, and then re-run `vsce up` - this will rebuild the container image and redeploy it. You should be able to see your code changes take effect.


But there is even a faster way with the VS Code extension for Connected Environemnt, which we'll now explore in the next section. 
> [!div class="nextstepaction"]
> [Debugging a container with the VS Code extension](get-started-netcore-04.md)

